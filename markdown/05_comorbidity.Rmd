# Comorbidity

```{r}


require(dplyr)
require(ggplot2)
require(rafalib)
require(igraph)

ae.data <- read.delim2("../data/REAC15Q4.txt",sep="$")

# Get an idea of how many data points we are looking at
ae.data %>% 
  summarize(n_patients = n_distinct(primaryid),
            n_aes      = n_distinct(pt))


set.seed(1234)

# FAERS dataset has over 31k patients. We will take a random sample of 10k patients to help ensure the structure of the eventual graph is representative of the population
sample_ids <- sample(unique(ae.data$primaryid),10000)


ae.data.subset <- ae.data %>%
  filter(primaryid %in% sample_ids)

# plot the frequencies of the 20 most common AEs
counts <- count(ae.data.subset,pt) %>% 
  arrange(-n) %>% 
  head(20)

ggplot(counts, aes(x = reorder(pt, n), y = n)) +
         geom_bar(stat = "identity") +
  coord_flip()



# We will only consider at most, one co-occurence of Adverse Events per patient
ae.data.unique <- ae.data.subset %>% 
  dplyr::select(primaryid, pt) %>% 
  mutate(primaryid = as.character(primaryid)) %>%
  unique() 


ae.data.expand <- ae.data.unique %>% full_join(ae.data.unique,by="primaryid") %>%
  filter (pt.x!=pt.y) %>%
  mutate(from=pt.x, to=pt.y) %>%
  select(from, to)


# Build the graph object from the data
g <- graph.data.frame(ae.data.expand, directed = FALSE)


# Assigning weight to adjacency graph. To avoid double counting A->B == B->A we will assign a weight of .5 to each instance of an edge and have igraph sum the weights
E(g)$weight <- .5
g <- simplify(g, edge.attr.comb=list(weight="sum"))



#G<-graph.data.frame(ae.data.unique, directed = FALSE)
# separating AEs from patient IDs
#V(G)$type <- grepl("[A-Z]+", V(G)$name)


# adjacency matrix, weighted by AE co-occurence
#bp<- bipartite.projection(G)

# Only considering Adverse event terms
#g <- g$proj2

#g <- simplify(g)


#The number of edges and verstices in our network


# Calculate the frequency of each Adverse Event
pt.freq <- ae.data.unique %>%
  group_by(pt) %>%
  summarise(nc=n()) %>%
  ungroup 


# Match the AE frequencies to their ordering in the Graph object
name.ord <- data.frame(names=V(g)$name,ord=seq(1:length(V(g)$name))) %>%
  left_join(pt.freq, by=c("names"="pt")) %>%
  arrange(ord)

# Apply the frequencies to be the node counts
V(g)$node_count <- name.ord$nc

# Lets find some info on our graph

vcount(g)

ecount(g)


# We don't expect all our Adverse events to be connected, so taking a look at the number of distinct clusters

g.components <- clusters(g)
g.components$csize


# We can see that we have one giant cluster of 3124 adverse events and 12 isolates that consist of a single unconnected pair. 

g.small <- induced.subgraph(g, which(g.components$membership != which.max(g.components$csize)))



g.small.layout <- layout.reingold.tilford(g.small, circular=TRUE)
plot(g.small,
     layout = g.small.layout,
     vertex.size = .5,
     vertex.label.cex = .6,
     edge.label.cex = .6,
     edge.label=E(g.small)$weight)

# Given that these AEs are rare with an edge weight of only one, there is not likely any strong releationship between them


# So we will continue the rest of the analysis keeping only the large central network
g.big <- induced.subgraph(g, which(g.components$membership == which.max(g.components$csize)))


#Given that they were obser


# Preliminary plot to show structure of the network
# Removing labels so we can see the underlying structure

#plot(g, 
#     layout = layout.fruchterman.reingold,
#     vertex.label = NA)


# From the network graph above, we can see that we have a few very strongly connected components. We will also have a lot of isolates that are connected to only 1 other node. We will remove these




# We can now see a much clearer structure, however, the graph is still too large to plot labels 

sub <- c("Nausea","Fatigue","Headache")
g.sub <- induced_subgraph(graph=g.big,vids=sub)



# Community detection



set.seed(1234)
# Detecting community strucution via short random walks
wc <- walktrap.community(g.big, weights = E(g.big)$weight, steps = 200, merges =
          TRUE, modularity = TRUE, membership = TRUE)

sizes(wc)


g.prune <- induced.subgraph(g.big, which(membership(wc)==14))


plot(g.prune,
     layout =layout_with_fr(g.prune),
     vertex.size = .5,
     vertex.label.cex = .6,
     edge.label.cex = .6)



#####################
dend <- as.dendrogram(wc, use.modularity=TRUE)
plot(dend)


eb <- edge.betweenness.community(g.subset)

plot(as.dendrogram(eb))








colors <- rainbow(max(membership(wc)))
plot(g.subset,
     vertex.size=.4,
     vertex.label = NA,
     vertex.color=colors[membership(wc)], 
     layout=lfr)


pc <- 


  
  
  
  
  

## Create community graph, edge weights are the number of edges
cg <- contract.vertices(g.big, membership(wc))
plot(cg)
cg2 <- simplify(cg, remove.loops=FALSE)

## Plot the community graph
plot(cg2,margin=.5)


plot(wc, g.subset, vertex.label=NA,  
     layout = layout_with_fr(g))

layout <-layout.fruchterman.reingold(g)

plot(g, layout=layout_with_fr(G),
  vertex.size=map(betweenness(g),c(1,15)),
  edge.width=map(edge.betweenness(g), c(1,10)))






##############################



#' # Diameter of graph - Length of the longest geodesic path
# longest shortest path
diameter(g.subset)
get.diameter(g.subset)

#' # Maximal independent vertex sets
independence.number(g.subset)

# mark the first maximal independent vertex set red
col <- rep("blue",length(V(g)))
col[maximal.independent.vertex.sets(g)[[1]]] <- "red"
plot(g, layout=layout, vertex.color=col)

#' # Find connected components
cl <- clusters(g.subset)
cl

layout <- layout.reingold.tilford(g.subset, circular=T)
plot(g.subset,vertex.label=NA, 
     layout=layout, vertex.color=cl$membership+1L)


#' # Get connected components
dg <- decompose.graph(g.subset)
length(dg)
plot(dg[[1]])
plot(dg[[2]])


#' # Max-flow  between vertices 1 and 2
graph.maxflow(g, 1, 2)

#' # Min cut (of the first connected component)
graph.mincut(dg[[1]], value.only=FALSE)

col <- rep("blue", length(V(dg[[1]])))
col[graph.mincut(dg[[1]], value.only=FALSE)[["partition2"]]] <- "red"
plot(dg[[1]], vertex.color=col)

#' # Find neighborhood of vertices
gn <- graph.neighborhood(g, order = 1)
plot(gn[[1]])
plot(gn[[2]])

#' # Find cliques
mc <- maximal.cliques(g)
length(mc)
#' click size
sapply(mc, length)
col <- rep("blue", length(V(g)))
#' plot the largest (last) click
col[mc[[length(mc)]]] <- "red"

plot(g, layout=layout, vertex.color=col)

#' ## Large graph (social networks)
g <- barabasi.game(1000, power=1)
layout <- layout.auto(g.subset)
plot(g.subset, layout=layout, vertex.size=2,
  vertex.label=NA, edge.arrow.size=.2)

#' # Page Rank
pr <- page.rank(g.subset)$vector
plot(g.subset, layout=layout, vertex.size=map(pr, c(1,20)),
  vertex.label=NA, edge.arrow.size=.2)

#' # Eigenvector centrality
ec <- evcent(g)$vector
plot(g, layout=layout, vertex.size=map(ec, c(1,20)), vertex.label=NA, edge.arrow.size=.2)

#' # Kleinberg's hub and authority scores
auth <- authority.score(g)$vector
hub <- hub.score(g)$vector
plot(g, layout=layout, vertex.size=map(hub, c(1,5)), vertex.label=NA, edge.arrow.size=.2)
plot(g, layout=layout, vertex.size=map(auth, c(1,20)), vertex.label=NA, edge.arrow.size=.2)

#' # Community detection (betweenness)
eb <- edge.betweenness.community(g)
#' create 10 communities
member <- community.to.membership(g, eb$merges,
  step=nrow(eb$merges)-10L+1L)
plot(g,
  vertex.color= rainbow(10, .8, .8, alpha=.8)[member$membership+1L],
  vertex.size=5, layout=layout,  vertex.label=NA,
  edge.arrow.size=.2)


#' # Random walk
eb <- walktrap.community(g)
#' create 10 communities
member <- community.to.membership(g, eb$merges,
  step=nrow(eb$merges)-10L+1L)
plot(g,
  vertex.color= rainbow(10, .8, .8, alpha=.8)[member$membership+1L],
  vertex.size=5, layout=layout,  vertex.label=NA,
  edge.arrow.size=.2)






cg2 <- set_graph_attr(cg2, "layout", layout_with_fr(G))
plot(cg2, vertex.label.dist=1.5)

plot(cg2, vertex.shape="none", vertex.label=V(G)$node_count, 
     vertex.label.font=2, vertex.label.color="gray40",
     vertex.label.cex=.7, edge.color="gray40")


com <- cluster_spinglass(G, spins=5)
V(G)$color <- com$membership+1
g <- set_graph_attr(g, "layout", layout_with_kk(G))
plot(g, vertex.label.dist=1.5)


g <- set_graph_attr(g, "layout", layout_with_fr(G))
plot(g, vertex.label.dist=1.5)


netm <- get.adjacency(G, attr="weight", sparse=F)
colnames(netm) <- V(net)$media
rownames(netm) <- V(net)$media

palf <- colorRampPalette(c("gold", "dark orange")) 
heatmap(G[], Rowv = NA, Colv = NA, col = palf(100), 
        scale="none", margins=c(10,10) )










# Creating an adjacency list, the weight will be how often adverse events are observed in co-occurence
adjacency.list <- ae.data.unique %>% 
  full_join(ae.data.unique,by="primaryid") %>% 
  filter(pt.x != pt.y) %>%
  group_by(pt.x, pt.y) %>%
  summarise(weight=n()) %>%
  ungroup %>%
  unique()


s <- sample_n(adjacency.list,100)

g <- graph.adjlist(s)
get.edgelist(g)


node_list <- get.data.frame(g, what = "edges")
all_nodes <- sort(node_list$name)
plot_data <- s %>% mutate(
        to = factor(pt.x, levels = all_nodes),
        from = factor(pt.y, levels = all_nodes))


# Create the adjacency matrix plot
ggplot(plot_data, aes(x = pt.x, y = pt.y, fill = group)) +
      geom_raster() +
      theme_bw() +
      # Because we need the x and y axis to display every node,
      # not just the nodes that have connections to each other,
      # make sure that ggplot does not drop unused factor levels
      scale_x_discrete(drop = FALSE) +
      scale_y_discrete(drop = FALSE) +
      theme(
        # Rotate the x-axis lables so they are legible
        axis.text.x = element_text(angle = 270, hjust = 0),
        # Force the plot into a square aspect ratio
        aspect.ratio = 1,
        # Hide the legend (optional)
        legend.position = "none")








g <- graph.adjacency(ff)
g <- get.edgelist(g)







require(igraph)
g <- graph.adjacency(v, weighted=TRUE, mode ='undirected')
g <- simplify(g)
# set labels and degrees of vertices
V(g)$label <- V(g1)$name
V(g)$label.cex <- .7

V(g)$degree <- degree(g)

set.seed(7867)

layout1 <- layout.auto(g)

opar <- par()$mar
par(mar=rep(0, 4)) #Give the graph lots of room
plot(g, layout=layout1)

edge.weight <- 7  #a maximizing thickness constant
z1 <- edge.weight*(1-dist(t(s), method="binary"))
E(g)$width <- c(z1) #remove 0s: these won't have an edge
z2 <- round(1-dist(t(X), method="binary"), 2)
E(g)$label <- c(z2)
plot(g, layout=layout1,edge.label=round(E(g)$weight, 3)) #check it out!


SUMS <- diag(Z) #frequency (same as colSums(X))
label.size <- .5 #a maximizing label size constant
V(g)$label.cex <- (log(SUMS)/max(log(SUMS))) + label.size
plot(g, layout=layout1) #check it out!


#interactive version
tkplot(g)  #an interactive version of the graph
tkplot(g, edge.curved =TRUE)





plot(g.sub,
     e)

plot(g2, 
     layout = layout_with_fr(g2))

sg1 <- decompose.graph(g,mode="weak")

neighverts <- unique(unlist(sapply(g,FUN=function(s){if(any(V(g)$name=="Nausea")) V(g)$name else NULL})))
g3 <- induced.subgraph(graph=g,vids=neighverts)
plot(g3,
     vertex.label.cex = .5
     )








```

